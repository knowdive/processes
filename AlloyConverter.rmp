<?xml version="1.0" encoding="UTF-8"?><process version="9.6.000">
  <context>
    <input/>
    <output/>
    <macros/>
  </context>
  <operator activated="true" class="process" compatibility="9.4.000" expanded="true" name="Process">
    <parameter key="logverbosity" value="init"/>
    <parameter key="logfile" value="/Users/mattiafumagalli/Desktop/prova.log"/>
    <parameter key="resultfile" value="/Users/mattiafumagalli/prova.res"/>
    <parameter key="random_seed" value="2001"/>
    <parameter key="send_mail" value="never"/>
    <parameter key="notification_email" value=""/>
    <parameter key="process_duration_for_mail" value="30"/>
    <parameter key="encoding" value="UTF-8"/>
    <process expanded="true">
      <operator activated="true" class="set_macros" compatibility="9.6.000" expanded="true" height="68" name="Set Macros" width="90" x="447" y="442">
        <list key="macros">
          <parameter key="inputFile" value="/home/marco/Desktop/Alloy/Converter/investigation.v00.owl"/>
          <parameter key="outputDirectory" value="/home/marco/Desktop/Alloy/Converter/Res/"/>
          <parameter key="AlloyDefinitions" value="/home/marco/Desktop/Alloy/AlloyDefinitions.als"/>
          <parameter key="AlloyUtilsFile" value="/home/marco/Desktop/Alloy/AlloyUtils.als"/>
        </list>
      </operator>
      <operator activated="false" class="python_scripting:execute_python" compatibility="9.2.000" expanded="true" height="82" name="Alloy Generator" width="90" x="916" y="544">
        <parameter key="script" value="#!/usr/bin/env python&#10;# -*- coding: utf-8 -*-&#10;&#10;# Based on:&#10;# https://www.researchgate.net/publication/272763162_A_Non-Standard_Approach_for_the_OWL_Ontologies_Checking_and_Reasoning&#10;&#10;import os&#10;import ontospy&#10;from rdflib import RDFS, OWL&#10;&#9;&#10;&#9;&#10;def nameOf(text):&#10;&#9;return (str(text).split(&quot;/&quot;))[-1].split(&quot;#&quot;)[-1]&#10;&#9;&#10;def domains(property_):&#10;&#9;property_domains = &quot;&quot;&#10;&#9;if(property_.domains):&#10;&#9;   for domain_ in property_.domains:&#10;&#9;       property_domains = property_domains + str(domain_.uri) + &quot; &quot;&#10;&#9;elif(property_.parents()):&#10;&#9;   for property_parent in property_.parents():&#10;&#9;       property_domains = property_domains + &quot; &quot; + &quot; &quot;.join(domains(property_parent))&#10;&#9;return property_domains.split()&#10;&#9;&#10;&#9;&#10;def ranges(property_):&#10;&#9;property_ranges = &quot;&quot;&#10;&#9;if(property_.ranges):&#10;&#9;   for range_ in property_.ranges:&#10;&#9;       property_ranges = property_ranges + str(range_.uri) + &quot; &quot;&#10;&#9;elif(property_.parents()):&#10;&#9;   for property_parent in property_.parents():&#10;&#9;       property_ranges = property_ranges + &quot; &quot; + &quot; &quot;.join(ranges(property_parent))&#10;&#9;return property_ranges.split()&#10;&#9;&#10;def rm_main():&#10;&#9;# Define Ontology Analyser&#9;&#10;&#9;o = ontospy.Ontospy()&#10;&#9;inputFile = &quot;%{inputFile}&quot; #, people.owl, Animal.owl, schema_2020-03-10.n3&#10;&#9;o.load_rdf(inputFile)&#10;&#9;&#10;&#9;# Create the directory in which store the new vocabulary&#10;&#9;outputDirectory = &quot;%{outputDirectory}&quot;&#10;&#9;if not os.path.isdir(outputDirectory):&#10;&#9;&#9;os.makedirs(outputDirectory)&#10;&#9;&#10;&#9;moduleName = ((str(inputFile).split(&quot;/&quot;)[-1]).split(&quot;.&quot;))[-2] + &quot;Generator&quot;&#10;&#9;fileName = outputDirectory + moduleName + &quot;.als&quot;&#10;&#9;&#10;&#9;o.build_all()&#10;&#9;&#10;&#9;print(o.stats())&#10;&#9;&#10;&#9;#print(o.all_classes)&#10;&#9;#print(o.all_properties)&#10;&#9;#print(o.all_shapes)&#10;&#9;#print(o.all_ontologies)&#10;&#9;#print(o.all_skos_concepts)&#10;&#9;#print(o.rdflib_graph)&#10;&#9;&#10;&#9;AlloyModel = &quot;&quot;&#10;&#9;&#10;&#9;for class_ in o.all_classes + [&quot;http://www.w3.org/2002/07/owl#Thing&quot;]:&#10;&#9;&#9;#print(&quot;Class: &quot; + str(class_.uri))&#10;&#9;&#9;if(&quot;owl#Thing&quot; in str(class_)):&#10;&#9;&#9;&#9;className = &quot;Thing&quot;&#10;&#9;&#9;&#9;AlloyClass = &quot;sig Thing in Individual { // Individual can be removed if not defined\n    &quot;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;className = nameOf(class_.uri)&#10;&#9;&#10;&#9;&#9;&#9;AlloyClass = &quot;sig &quot; + className&#10;&#9;&#10;&#9;&#9;&#9;for subClassOf in class_.parents():&#10;&#9;&#9;&#9;&#9;subClassOfName = nameOf(subClassOf.uri)&#10;&#9;&#9;&#9;&#9;if(&quot; in &quot; not in AlloyClass):&#10;&#9;&#9;&#9;&#9;&#9;AlloyClass = AlloyClass + &quot; in &quot; + subClassOfName&#10;&#9;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;&#9;AlloyClass = AlloyClass + &quot; + &quot; + subClassOfName&#10;&#9;&#10;&#9;&#9;&#9;AlloyClass = AlloyClass + &quot; { \n\t&quot;&#10;&#9;&#10;&#9;&#9;for property_ in o.all_properties:&#10;&#9;&#9;&#9;#print(&quot;Property: &quot; + str(property_.uri))&#10;&#9;&#9;&#9;domains_ = domains(property_)&#10;&#9;&#9;&#9;property_Name = nameOf(property_.uri)&#10;&#9;&#9;&#9;for domain_ in domains_:&#10;&#9;&#9;&#9;&#9;if(nameOf(domain_) == str(className)):&#10;&#9;&#9;&#9;&#9;&#9;print(&quot;Domain: &quot; + str(domain_))&#10;&#9;&#9;&#9;&#9;&#9;ranges_ = ranges(property_)&#10;&#9;&#9;&#9;&#9;&#9;for range_ in ranges_:&#10;&#9;&#9;&#9;&#9;&#9;&#9;print(&quot;Range: &quot; + str(range_))&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyClass = AlloyClass + property_Name + &quot;: &quot; + nameOf(range_) + &quot;,\n\t&quot;&#10;&#9;&#10;&#9;&#9;AlloyClass = AlloyClass[0:-3] + &quot;} \n&quot;&#10;&#9;&#9;&#10;&#9;&#9;AlloyModel = AlloyModel + AlloyClass&#10;&#9;&#9;#print()&#10;&#9;&#10;&#9;with open(fileName, &quot;w+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(&quot;module &quot;+ moduleName + &quot;\n\n&quot;)&#10;&#9;&#9;Alloy.write(AlloyModel)&#10;&#9;&#10;&#9;AlloyModel = &quot;&quot;&#10;&#9;notAlloyModel = &quot;&quot;&#10;&#9;notAlloyPred = set()&#10;&#9;&#10;&#9;for subject, predicate, object_ in o.rdflib_graph:&#10;&#9;&#9;predicateName = nameOf(predicate.encode('utf-8').strip())&#10;&#9;&#9;if(predicateName != &quot;type&quot;):&#10;&#9;&#9;&#9;#print(subject, predicate, object_)&#10;&#9;&#9;&#9;#print()&#10;&#9;&#9;&#10;&#9;&#9;&#9;subj = o.get_any_entity(uri=subject.encode('utf-8').strip())&#10;&#9;&#9;&#9;pred = o.get_any_entity(uri=predicate.encode('utf-8').strip())&#10;&#9;&#9;&#9;obj = o.get_any_entity(uri=object_.encode('utf-8').strip())&#10;&#9;&#10;&#9;&#9;&#9;if(subj and obj):&#10;&#9;&#9;&#9;&#9;if predicateName == &quot;subPropertyOf&quot;:       &#10;&#9;&#9;&#9;&#9;&#9;subj_range = &quot;&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(subj)[1:9] and subj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(subj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;&#9;subj_range = subj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;&#9;elif(&quot;Class&quot; == str(subj)[1:6] and subj.range_of):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(subj.range_of))&#10;&#9;&#9;&#9;&#9;&#9;&#9;subj_range = subj.range_of[0].uri            &#10;&#9;&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;// subPropertyOf as Figure4\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(nameOf(subj_range) and nameOf(subj.uri) and nameOf(obj.uri)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred subPropertyOf{all a:&quot; + nameOf(subj_range) + &quot; | a.&quot; + nameOf(subj.uri) + &quot; in a.&quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;&#9;obj_range = &quot;&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(obj)[1:9] and obj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(obj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;&#9;obj_range = obj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;&#9;elif(&quot;Class&quot; == str(obj)[1:6] and obj.range_of):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(obj.range_of))&#10;&#9;&#9;&#9;&#9;&#9;&#9;obj_range = obj.range_of[0].uri&#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;if(nameOf(subj_range) and nameOf(obj_range)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;// subPropertyOf as TABLE I\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred subPropertyOf{all r:&quot; + nameOf(subj_range) + &quot; | r in &quot; + nameOf(obj_range) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName == &quot;inverseOf&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred inverseOf{&quot; + nameOf(subj.uri) + &quot; = ~&quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;disjointWith&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if(subj.parents() and obj.parents() and subj.parents()[0] != obj.parents()[0]):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred { no c1:&quot; + nameOf(subj.uri) + &quot;, c2:&quot; + nameOf(obj.uri) + &quot;| c1 = c2}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;complementOf&quot;:&#10;&#9;&#9;&#9;&#9;&#9;C = &quot;{&quot;&#10;&#9;&#9;&#9;&#9;&#9;for class_ in o.all_classes:&#10;&#9;&#9;&#9;&#9;&#9;&#9;if(nameOf(obj.uri) != nameOf(class_.uri)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;C = C + nameOf(class_.uri)&#10;&#9;&#9;&#9;&#9;&#9;C = C + &quot;}&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred { &quot; + nameOf(subj.uri) + &quot; = &quot; + str(C) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;equivalentClass&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred equivalentClass{ &quot; + nameOf(subj.uri) + &quot; = &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;equivalentProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred equivalentProperty{ &quot; + nameOf(subj.uri) + &quot; = &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;TransitiveProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred TransitiveProperty{ a,b,c ∈ &quot; + nameOf(subj.uri) + &quot; / a.(&quot; + nameOf(predicate) + &quot;) = b &amp;&amp; b.(&quot; + nameOf(predicate) + &quot;) = c ⇒ a.(&quot; + nameOf(predicate) + &quot;) = c }&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;hasValue&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred hasValue{ #( &quot; + pred.ranges[0] + &quot; ) = 1}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;cardinality&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred cardinality{ #( &quot; + pred.ranges[0] + &quot; ) = &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;maxCardinality&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred maxCardinality{ #( &quot; + pred.ranges[0] + &quot; ) &lt;= &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;minCardinality&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred minCardinality{ #( &quot; + pred.ranges[0] + &quot; ) &gt;= &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;SymmetricProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if(((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)) and ((&quot;Property&quot; == str(pred)[1:9] and pred.domains) or (&quot;Class&quot; == str(pred)[1:6] and pred.domain_of))):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred SymmetricProperty{ a ∈ &quot; + pred.domains[0] + &quot; &amp;&amp;  b ∈ &quot; + pred.ranges[0] + &quot; / a.(&quot; + nameOf(predicate) + &quot;)  = b ⇒ b.(&quot; + nameOf(predicate) + &quot;) }&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;FunctionalProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred FunctionalProperty{ #(&quot; + pred.ranges[0] + &quot;) = 1}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;InverseFunctionalProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.domains) or (&quot;Class&quot; == str(pred)[1:6] and pred.domain_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred InverseFunctionalProperty{ #(&quot; + pred.domains[0] + &quot;) = 1}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;allValuesFrom&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred allValuesFrom{ &quot; + nameOf(pred.ranges[0]) + &quot; in &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;someValuesFrom&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred allValuesFrom{ some r: &quot; + nameOf(pred.ranges[0]) + &quot; | r in &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;&#9;notAlloyModel = notAlloyModel + str(subject.encode('utf-8').strip()) + &quot;,\t&quot; + str(predicate.encode('utf-8').strip()) + &quot;,\t&quot; + str(object_.encode('utf-8').strip()) + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;notAlloyPred.add(str(predicate))&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;notAlloyModel = notAlloyModel + str(subject.encode('utf-8').strip()) + &quot;,\t&quot; + str(predicate.encode('utf-8').strip()) + &quot;,\t&quot; + str(object_.encode('utf-8').strip()) + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;#notAlloyPred.add(str(predicate))&#10;&#9;&#9;&#9;&#10;&#9;&#10;&#9;with open(fileName, &quot;a+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(&quot;\n&quot;)&#10;&#9;&#9;Alloy.write(AlloyModel)&#10;&#9;&#10;&#9;AlloyUtils = &quot;&quot;&#10;&#9;AlloyUtilsFile = &quot;%{AlloyUtilsFile}&quot;&#10;&#9;with open(AlloyUtilsFile, &quot;r&quot;) as AlloyUtilsFileRead:&#10;&#9;&#9;AlloyUtils = AlloyUtilsFileRead.read()&#10;&#9;&#10;&#9;with open(fileName, &quot;a+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(&quot;\n&quot;)&#10;&#9;&#9;Alloy.write(AlloyUtils)&#10;&#9;&#10;&#9;with open(fileName+&quot;_notAlloy.csv&quot;, &quot;w+&quot;) as notAlloy:&#10;&#9;&#9;notAlloy.write(&quot;List of all the triples not used for Alloy conversion\n&quot;)&#10;&#9;&#9;notAlloy.write(notAlloyModel)&#10;&#9;&#10;&#9;with open(fileName+&quot;_notAlloyPredicates.csv&quot;, &quot;w+&quot;) as notAlloyPredicates:&#10;&#9;&#9;notAlloyPredicates.write(&quot;List of predicates in valid triples(i.e. those without BlankNodes) not used for Alloy conversion\n&quot;)&#10;&#9;&#9;for pred in notAlloyPred:&#10;&#9;&#9;&#9;notAlloyPredicates.write(pred + &quot;\n&quot;)"/>
        <parameter key="use_default_python" value="false"/>
        <parameter key="package_manager" value="specific python binaries"/>
        <parameter key="python_binary" value="/usr/bin/python"/>
      </operator>
      <operator activated="false" class="python_scripting:execute_python" compatibility="9.2.000" expanded="true" height="82" name="AlloyCreator" width="90" x="916" y="748">
        <parameter key="script" value="#!/usr/bin/env python&#10;# -*- coding: utf-8 -*-&#10;&#10;# Based on:&#10;# https://www.researchgate.net/publication/220535396_Reasoning_support_for_Semantic_Web_ontology_family_languages_using_Alloy&#10;&#10;import ontospy&#10;import os&#10;from rdflib import RDFS, OWL&#10;&#10;def nameOf(text):&#10;    return (str(text).split(&quot;/&quot;))[-1].split(&quot;#&quot;)[-1]&#10;&#10;def rm_main():&#10;&#9;# Define Ontology Analyser&#9;&#10;&#9;o = ontospy.Ontospy()&#10;&#9;AlloyDefinitions = &quot;&quot;&#10;&#9;inputFile = &quot;%{inputFile}&quot; #, people.owl, Animal.owl, schema_2020-03-10.n3&#10;&#9;o.load_rdf(inputFile)&#10;&#10;&#9;# Create the directory in which store the new vocabulary&#10;&#9;outputDirectory = &quot;%{outputDirectory}&quot;&#10;&#9;if not os.path.isdir(outputDirectory):&#10;&#9;&#9;os.makedirs(outputDirectory)&#10;     &#10;&#9;moduleName = ((str(inputFile).split(&quot;/&quot;)[-1]).split(&quot;.&quot;))[-2]  + &quot;Creator&quot;&#10;&#9;fileName = outputDirectory + moduleName + &quot;.als&quot;&#10;&#9;&#10;&#9;o.build_all()&#10;&#9;&#10;&#9;print(o.stats())&#10;&#9;&#10;&#9;AlloyModel = &quot;// Classes Definitions \n&quot;&#10;&#9;&#10;&#9;for class_ in o.all_classes:&#10;&#9;    #print(&quot;Class: &quot; + str(class_.uri))&#10;&#9;    className = nameOf(class_.uri)&#10;&#9;    AlloyModel = AlloyModel + &quot;sig &quot; + className + &quot; in Class{}\n&quot; #static&#10;&#9;&#10;&#9;AlloyModel = AlloyModel + &quot;\n// Properties Definitions \n&quot;&#10;&#9;&#10;&#9;for property_ in o.all_properties:&#10;&#9;    #print(&quot;Property: &quot; + str(property_.uri))&#10;&#9;    property_Name = nameOf(property_.uri)&#10;&#9;    AlloyModel = AlloyModel + &quot;sig &quot; + property_Name + &quot; in Property{}\n&quot; #static&#10;&#10;&#9;AlloyDefinitions = &quot;&quot;&#10;&#9;with open(&quot;%{AlloyDefinitions}&quot;, &quot;r&quot;) as AlloyDefinitionsFile:&#10;&#9;&#9;AlloyDefinitions = AlloyDefinitionsFile.read()&#10;&#9;&#9;&#10;&#9;with open(fileName, &quot;w+&quot;) as Alloy:&#10;&#9;    Alloy.write(&quot;module &quot;+ moduleName + &quot;\n\n&quot;)&#10;&#9;    &#10;&#9;    Alloy.write(AlloyDefinitions + &quot;\n\n&quot;)&#10;&#9;    &#10;&#9;    Alloy.write(AlloyModel)"/>
        <parameter key="use_default_python" value="false"/>
        <parameter key="package_manager" value="specific python binaries"/>
        <parameter key="python_binary" value="/usr/bin/python"/>
      </operator>
      <operator activated="true" class="read_excel" compatibility="9.6.000" expanded="true" height="68" name="Read Excel" width="90" x="916" y="340">
        <parameter key="excel_file" value="/home/marco/Desktop/Alloy/Converter/investigation.v00.xlsx"/>
        <parameter key="sheet_selection" value="sheet number"/>
        <parameter key="sheet_number" value="1"/>
        <parameter key="imported_cell_range" value="A1"/>
        <parameter key="encoding" value="UTF-8"/>
        <parameter key="first_row_as_names" value="true"/>
        <list key="annotations"/>
        <parameter key="date_format" value=""/>
        <parameter key="time_zone" value="SYSTEM"/>
        <parameter key="locale" value="English (United States)"/>
        <parameter key="read_all_values_as_polynominal" value="false"/>
        <list key="data_set_meta_data_information">
          <parameter key="0" value="DLAxioms.true.polynominal.attribute"/>
          <parameter key="1" value="id.true.integer.attribute"/>
        </list>
        <parameter key="read_not_matching_values_as_missings" value="false"/>
        <parameter key="datamanagement" value="double_array"/>
        <parameter key="data_management" value="auto"/>
      </operator>
      <operator activated="true" class="python_scripting:execute_python" compatibility="9.2.000" expanded="true" height="103" name="OWL+DL-&gt;Alloy" width="90" x="1117" y="340">
        <parameter key="script" value="#!/usr/bin/env python&#10;# -*- coding: utf-8 -*-&#10;&#10;&#10;# Based on:&#10;# https://www.researchgate.net/publication/272763162_A_Non-Standard_Approach_for_the_OWL_Ontologies_Checking_and_Reasoning&#10;# https://www.researchgate.net/publication/252772655_Model_Generation_in_Description_Logics_What_Can_We_Learn_From_Software_Engineering&#10;&#10;import os&#10;import pandas as pd&#10;import ontospy&#10;import re&#10;&#10;&#10;def nameOf(text):&#10;    return (str(text).split(&quot;/&quot;))[-1].split(&quot;#&quot;)[-1]&#10;&#10;&#10;def domains(property_):&#10;    property_domains = &quot;&quot;&#10;    if(property_.domains):&#10;        for domain_ in property_.domains:&#10;            property_domains = property_domains + str(domain_.uri) + &quot; &quot;&#10;    elif(property_.parents()):&#10;        for property_parent in property_.parents():&#10;            property_domains = property_domains + &quot; &quot; + &quot; &quot;.join(domains(property_parent))&#10;    return property_domains.split()&#10;&#10;&#10;def ranges(property_):&#10;    property_ranges = &quot;&quot;&#10;    if(property_.ranges):&#10;        for range_ in property_.ranges:&#10;            property_ranges = property_ranges + str(range_.uri) + &quot; &quot;&#10;    elif(property_.parents()):&#10;        for property_parent in property_.parents():&#10;            property_ranges = property_ranges + &quot; &quot; + &quot; &quot;.join(ranges(property_parent))&#10;    return property_ranges.split()&#10;&#10;&#10;&#10;def brackets(complete):&#10;&#9;#print(complete)&#10;&#9;tmp = filter(None, complete.split(&quot;(&quot;) ) &#10;&#9;bracketed = &quot;&quot;&#10;&#9;c = 0 # Count level of opened brackets&#10;&#9;for t in tmp: # Iterate over the string to build the original one&#10;&#9;&#9;if(c):&#10;&#9;&#9;&#9;bracketed = bracketed + &quot; ( &quot;&#10;&#9;&#9;c = c + 1&#10;&#9;&#9;for i in t: # Iterate over every element to identify closed brackets&#10;&#9;&#9;&#9;if i == ')': # If a bracket is closed then update the opened brackets counter&#10;&#9;&#9;&#9;&#9;c = c - 1 &#10;&#9;&#9;&#9;&#9;if c &lt; 1: # If all the brackets has been closed then return the result&#10;&#9;&#9;&#9;&#9;&#9;return bracketed&#10;&#9;&#9;&#9;bracketed = bracketed + i&#10;&#10;&#9;while c &gt; 1: # If there are less closed brackets add the remaining ones&#10;&#9;&#9;bracketed = bracketed + &quot; ) &quot;&#10;&#9;&#9;c = c - 1 &#10;&#9;return bracketed # Return correctly formatted bracketed result&#10;&#10;# Return next expression inside brackets if the first string open a bracket&#10;def nextBrackets(next, complete):&#10;&#9;if(&quot;(&quot; in next): &#10;&#9;&#9;return brackets(&quot; &quot;.join(complete))&#10;&#9;else:&#10;&#9;&#9;return brackets(next)&#10;&#10;&#10;&#10;def DLAxiomtoAlloy(axiom, level):&#10;&#10;&#9;print(axiom)&#10;&#10;&#9;# TBOX&#10;&#9;if(&quot;≡&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;≡&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy( tmp[0] , level + 1 ) + &quot; = &quot; + DLAxiomtoAlloy( tmp[1] , level + 1 ) + &quot; }&quot;&#10;&#10;&#9;elif(&quot;⊑&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;⊑&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy( tmp[0] , level + 1 ) + &quot; in  ( &quot; + DLAxiomtoAlloy( tmp[1] , level + 1 ) + &quot; )  }&quot;&#10;&#9;&#10;&#10;&#9;# (ALC) concept&#10;&#9;elif(&quot;⊔&quot; in axiom):&#10;&#9;&#9;tmps = axiom.split(&quot;⊔&quot;)&#10;&#10;&#9;&#9;#print(tmps)&#10;&#10;&#9;&#9;final = &quot;  &quot;&#10;&#10;&#9;&#9;for tmp in tmps:&#10;&#9;&#9;&#9;final = final + DLAxiomtoAlloy(tmp , level + 1) + &quot; + &quot;&#10;&#10;&#9;&#9;final = final[0:-2]&#10;&#10;&#9;&#9;return final&#10;&#10;&#9;elif(&quot;⊓&quot; in axiom):&#10;&#9;&#9;tmps = axiom.split(&quot;⊓&quot;)&#10;&#10;&#9;&#9;#print(tmps)&#10;&#10;&#9;&#9;final = &quot;  &quot;&#10;&#10;&#9;&#9;for tmp in tmps:&#10;&#9;&#9;&#9;final = final + DLAxiomtoAlloy(tmp , level + 1) + &quot; &amp; &quot;&#10;&#10;&#9;&#9;final = final[0:-2]&#10;&#10;&#9;&#9;return final&#10;&#10;&#9;elif(&quot;∀&quot; in axiom):&#10;&#9;&#9;tmp = axiom.replace('∀', '').split(&quot;.&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#9;&#9;&#10;&#9;&#9;return &quot; ( univ - ( &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot;.( univ - &quot; + DLAxiomtoAlloy(nextBrackets(&quot;.&quot;.join(tmp[1:]).split()[0], &quot;.&quot;.join(tmp[1:]).split()) , level + 1) + &quot; ) ) ) &quot;&#10;&#9;&#9;&#10;&#9;elif(&quot;∃&quot; in axiom):&#10;&#9;&#9;tmp = axiom.replace('∃', '')&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return DLAxiomtoAlloy(tmp , level + 1)&#10;&#9;&#9;&#10;&#9;elif(&quot;¬&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;¬&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return  &quot;( univ - &quot; + DLAxiomtoAlloy(nextBrackets(tmp[1].split()[0], tmp[1].split()) , level + 1) + &quot; ) &quot;&#10;&#9;&#9;&#10;&#9;elif(&quot;⁻&quot; in axiom):&#10;&#9;&#9;&#10;&#9;&#9;#print(axiom)&#10;&#10;&#9;&#9;for tmp in axiom.split():&#10;&#9;&#9;&#9;if(&quot;⁻&quot; in tmp):&#10;&#10;&#9;&#9;&#9;&#9;return &quot;( ~ &quot; + DLAxiomtoAlloy(tmp.replace(&quot;⁻&quot;, &quot;&quot;) , level + 1) + &quot; ) &quot;&#10;&#10;&#9;# (SHIQ) concept&#10;&#10;&#9;elif(&quot;≤&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;≤&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;tmp = tmp[1]&#10;&#10;&#9;&#9;n = re.findall('\d+',  tmp)[0]&#10;&#10;&#9;&#9;tmp = tmp.replace(str(n),&quot;&quot;)&#10;&#9;&#9;&#10;&#9;&#9;if(&quot;.&quot; in tmp):&#10;&#9;&#9;&#9;tmp = tmp.split(&quot;.&quot;)&#10;&#10;&#9;&#9;&#9;#print(n)&#10;&#9;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp[0].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; :&gt; &quot; + DLAxiomtoAlloy(tmp[1].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) =&lt; &quot; + n + &quot;}&quot; &#10;&#9;&#9;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) =&lt; &quot; + n + &quot;}&quot; &#10;&#10;&#9;elif(&quot;≥&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;≥&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;tmp = tmp[1]&#10;&#10;&#9;&#9;n = re.findall('\d+',  tmp)[0]&#10;&#10;&#9;&#9;tmp = tmp.replace(str(n),&quot;&quot;)&#10;&#9;&#9;&#10;&#9;&#9;if(&quot;.&quot; in tmp):&#10;&#9;&#9;&#9;tmp = tmp.split(&quot;.&quot;)&#10;&#10;&#9;&#9;&#9;#print(n)&#10;&#9;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp[0].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; :&gt; &quot; + DLAxiomtoAlloy(tmp[1].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) =&gt; &quot; + n + &quot;}&quot; &#10;&#9;&#9;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) =&gt; &quot; + n + &quot;}&quot; &#10;&#10;&#9;elif(&quot;=&quot; in axiom and level &gt; 0):&#10;&#9;&#9;tmp = axiom.split(&quot;=&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;tmp = tmp[1]&#10;&#10;&#9;&#9;n = re.findall('\d+',  tmp)[0]&#10;&#10;&#9;&#9;tmp = tmp.replace(str(n),&quot;&quot;)&#10;&#9;&#9;&#10;&#9;&#9;if(&quot;.&quot; in tmp):&#10;&#9;&#9;&#9;tmp = tmp.split(&quot;.&quot;)&#10;&#10;&#9;&#9;&#9;#print(n)&#10;&#9;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp[0].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; :&gt; &quot; + DLAxiomtoAlloy(tmp[1].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) = &quot; + n + &quot;}&quot; &#10;&#9;&#9;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) = &quot; + n + &quot;}&quot; &#10;&#9;&#10;&#9;elif(&quot;INV.&quot; in axiom):&#10;&#9;&#9;tmp = axiom.replace(&quot;INV.&quot;, &quot;~&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return DLAxiomtoAlloy(tmp , level + 1)&#10;&#10;&#10;&#9;elif(&quot;(&quot; in axiom and &quot;)&quot; in axiom and level == 0):&#10;&#9;&#9;tmp = axiom.split(&quot;(&quot;)&#10;&#9;&#9;C = tmp[0].split()[-1]&#10;&#9;&#9;tmp = tmp[1].split(&quot;)&quot;)[0]&#10;&#9;&#9;tmp = tmp.split(&quot;,&quot;)&#10;&#9;&#9;if(len(tmp)==1):&#10;&#9;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot; in &quot; + C + &quot; }&quot;&#10;&#9;&#9;elif(len(tmp)==2):&#10;&#9;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot; -&gt; &quot; + DLAxiomtoAlloy(tmp[1] , level + 1) + &quot; in &quot; + C + &quot; }&quot;&#10;&#9;&#9;return axiom#&quot;fact { &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot; -&gt; &quot; + DLAxiomtoAlloy(tmp[1] , level + 1) + &quot; in &quot; + C + &quot; }&quot;&#10;&#10;&#10;&#9;return axiom.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;)&#10;&#10;&#10;def rm_main(dataDL):&#10;&#10;&#9;# Create the directory in which store the new vocabulary&#10;&#9;outputDirectory = &quot;%{outputDirectory}&quot;&#10;&#9;if not os.path.isdir(outputDirectory):&#10;&#9;&#9;os.makedirs(outputDirectory)&#10;&#10;&#9;# Define Ontology Analyser&#9;&#10;&#9;o = ontospy.Ontospy()&#10;&#9;# Load Ontology&#10;&#9;inputFile = &quot;%{inputFile}&quot;&#10;&#9;o.load_rdf(inputFile)&#10;&#9;o.build_all()&#10;     &#10;&#9;moduleName = ((str(inputFile).split(&quot;/&quot;)[-1]).split(&quot;.&quot;))[-2] + &quot;DL&quot;&#10;&#9;fileName = outputDirectory + moduleName + &quot;.als&quot;&#10;&#9;&#10;&#9;AlloyModel = &quot;module &quot; + moduleName + &quot;\n\n&quot;&#10;&#10;&#9;usedProperties = set()&#10;&#10;&#9;AlloySignatures = &quot;\n// Signatures\n&quot;&#10;&#10;&#9;# Add Classes &amp; Properties to Alloy&#10;&#9;for class_ in o.all_classes:&#10;&#9;&#9;#print(&quot;Class: &quot; + str(class_.uri))&#10;&#9;&#9;className = nameOf(class_.uri)&#10;&#10;&#9;&#9;AlloyClass = &quot;sig &quot; + className + &quot; in TOP &quot;&#10;&#10;&#9;&#9;&quot;&quot;&quot;&#10;&#9;&#9;for subClassOf in class_.parents():&#10;&#9;&#9;&#9;subClassOfName = nameOf(subClassOf.uri)&#10;&#9;&#9;&#9;AlloyClass = AlloyClass + &quot; extends &quot; + subClassOfName&#10;&#9;&#9;&quot;&quot;&quot;&#10;&#9;&#9;AlloyClass = AlloyClass + &quot; { \n\t&quot;&#10;&#10;&#9;&#9;for property_ in o.all_properties:&#10;&#9;&#9;&#9;#print(&quot;Property: &quot; + str(property_.uri))&#10;&#9;&#9;&#9;domains_ = domains(property_)&#10;&#9;&#9;&#9;property_Name = nameOf(property_.uri)&#10;&#9;&#9;&#9;for domain_ in domains_:&#10;&#9;&#9;&#9;&#9;if(domain_ == str(class_.uri)):&#10;&#9;&#9;&#9;&#9;&#9;#print(&quot;Domain: &quot; + str(domain_))&#10;&#9;&#9;&#9;&#9;&#9;ranges_ = ranges(property_)&#10;&#9;&#9;&#9;&#9;&#9;for range_ in ranges_:&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(&quot;Range: &quot; + str(range_))&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyClass = AlloyClass + property_Name + &quot;: &quot; + nameOf(range_) + &quot;,\n\t&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;usedProperties.add(property_Name)&#10;&#10;&#9;&#9;AlloyClass = AlloyClass[0:-3] + &quot;} \n&quot;&#10;&#9;&#9;&#10;&#9;&#9;AlloySignatures = AlloySignatures + AlloyClass&#10;&#9;&#9;#print()&#10;&#10;&#10;&#9;AlloyModel = AlloyModel + &quot;abstract sig TOP { \n&quot;&#10;&#10;&#9;for property_ in o.all_properties:&#10;&#9;&#9;property_Name = nameOf(property_.uri)&#10;&#9;&#9;if(property_Name not in usedProperties):&#10;&#9;&#9;&#9;#print(property_Name)&#10;&#9;&#9;&#9;AlloyModel = AlloyModel + property_Name + &quot; : set TOP,\n&quot;&#10;&#10;&#9;AlloyModel = AlloyModel[0:-2] + &quot;}\n&quot;&#10;&#9;AlloyModel = AlloyModel + &quot;sig BOTTOM in TOP {} fact { #BOTTOM = 0 } \n\n&quot;&#10;&#10;&#10;&#9;AlloyAxioms = &quot;\n// Axioms\n&quot;&#10;&#10;&#9;# Iterate for every DL Axioms&#10;&#9;for index, row in dataDL.iterrows():&#10;&#10;&#9;&#9;if (row[&quot;DLAxioms&quot;]):&#10;&#9;&#9;&#9;axiom = row[&quot;DLAxioms&quot;].encode('utf-8').strip()&#10;&#10;&#9;&#9;&#9;AlloyAxiom = DLAxiomtoAlloy(axiom.replace(&quot;⊤&quot;, &quot;TOP&quot;).replace(&quot;,&quot;, &quot;&quot;), 0)&#10;&#10;&#9;&#9;&#9;if (AlloyAxiom[0] == &quot;{&quot;):&#10;&#9;&#9;&#9;&#9;AlloyAxiom = &quot;fact  &quot; + AlloyAxiom&#10;&#9;&#9;&#9;#print(AlloyAxiom)&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;if(&quot;fact {&quot; in AlloyAxiom[0:6]):&#10;&#9;&#9;&#9;&#9;AlloyAxioms = AlloyAxioms + AlloyAxiom + &quot;\n&quot;&#10;&#9;&#9;&#9;#print(&quot;&quot;)&#10;&#10;&#9;AlloyPredicates = &quot;\n// Predicates\n&quot;&#10;&#10;&#9;for subject, predicate, object_ in o.rdflib_graph:&#10;&#9;&#9;predicateName = nameOf(predicate.encode('utf-8').strip())&#10;&#9;&#9;if(predicateName != &quot;type&quot;):&#10;&#9;&#9;&#9;#print(subject, predicate, object_)&#10;&#9;&#9;&#9;#print()&#10;&#9;&#9;&#10;&#9;&#9;&#9;subj = o.get_any_entity(uri=subject.encode('utf-8').strip())&#10;&#9;&#9;&#9;pred = o.get_any_entity(uri=predicate.encode('utf-8').strip())&#10;&#9;&#9;&#9;obj = o.get_any_entity(uri=object_.encode('utf-8').strip())&#10;&#10;&#9;&#9;&#9;if(subj and obj):&#10;&#9;&#9;&#9;&#9;if predicateName == &quot;subPropertyOf&quot;:       &#10;&#9;&#9;&#9;&#9;&#9;subj_range = &quot;&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(subj)[1:9] and subj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(subj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;&#9;subj_range = subj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;&#9;elif(&quot;Class&quot; == str(subj)[1:6] and subj.range_of):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(subj.range_of))&#10;&#9;&#9;&#9;&#9;&#9;&#9;subj_range = subj.range_of[0].uri            &#10;&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;// subPropertyOf as Figure4\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(nameOf(subj_range) and nameOf(subj.uri) and nameOf(obj.uri)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred subPropertyOf{all a:&quot; + nameOf(subj_range) + &quot; | a.&quot; + nameOf(subj.uri) + &quot; in a.&quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;&#9;obj_range = &quot;&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(obj)[1:9] and obj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(obj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;&#9;obj_range = obj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;&#9;elif(&quot;Class&quot; == str(obj)[1:6] and obj.range_of):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(len(obj.range_of))&#10;&#9;&#9;&#9;&#9;&#9;&#9;obj_range = obj.range_of[0].uri&#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;if(nameOf(subj_range) and nameOf(obj_range)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;// subPropertyOf as TABLE I\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred subPropertyOf{all r:&quot; + nameOf(subj_range) + &quot; | r in &quot; + nameOf(obj_range) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName == &quot;inverseOf&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred inverseOf{&quot; + nameOf(subj.uri) + &quot; = ~&quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;disjointWith&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if(subj.parents() and obj.parents() and subj.parents()[0] != obj.parents()[0]):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred { no c1:&quot; + nameOf(subj.uri) + &quot;, c2:&quot; + nameOf(obj.uri) + &quot;| c1 = c2}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;complementOf&quot;:&#10;&#9;&#9;&#9;&#9;&#9;C = &quot;{&quot;&#10;&#9;&#9;&#9;&#9;&#9;for class_ in o.all_classes:&#10;&#9;&#9;&#9;&#9;&#9;&#9;if(nameOf(obj.uri) != nameOf(class_.uri)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;C = C + nameOf(class_.uri)&#10;&#9;&#9;&#9;&#9;&#9;C = C + &quot;}&quot;&#10;&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred { &quot; + nameOf(subj.uri) + &quot; = &quot; + str(C) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;equivalentClass&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred equivalentClass{ &quot; + nameOf(subj.uri) + &quot; = &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;equivalentProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred equivalentProperty{ &quot; + nameOf(subj.uri) + &quot; = &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;TransitiveProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred TransitiveProperty{ a,b,c ∈ &quot; + nameOf(subj.uri) + &quot; / a.(&quot; + nameOf(predicate) + &quot;) = b &amp;&amp; b.(&quot; + nameOf(predicate) + &quot;) = c ⇒ a.(&quot; + nameOf(predicate) + &quot;) = c }&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;hasValue&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred hasValue{ #( &quot; + pred.ranges[0] + &quot; ) = 1}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;cardinality&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred cardinality{ #( &quot; + pred.ranges[0] + &quot; ) = &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;maxCardinality&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred maxCardinality{ #( &quot; + pred.ranges[0] + &quot; ) &lt;= &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;minCardinality&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred minCardinality{ #( &quot; + pred.ranges[0] + &quot; ) &gt;= &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;SymmetricProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if(((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)) and ((&quot;Property&quot; == str(pred)[1:9] and pred.domains) or (&quot;Class&quot; == str(pred)[1:6] and pred.domain_of))):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred SymmetricProperty{ a ∈ &quot; + pred.domains[0] + &quot; &amp;&amp;  b ∈ &quot; + pred.ranges[0] + &quot; / a.(&quot; + nameOf(predicate) + &quot;)  = b ⇒ b.(&quot; + nameOf(predicate) + &quot;) }&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;FunctionalProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred FunctionalProperty{ #(&quot; + pred.ranges[0] + &quot;) = 1}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;InverseFunctionalProperty&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.domains) or (&quot;Class&quot; == str(pred)[1:6] and pred.domain_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred InverseFunctionalProperty{ #(&quot; + pred.domains[0] + &quot;) = 1}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;allValuesFrom&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred allValuesFrom{ &quot; + nameOf(pred.ranges[0]) + &quot; in &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;elif predicateName ==  &quot;someValuesFrom&quot;:&#10;&#9;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;pred allValuesFrom{ some r: &quot; + nameOf(pred.ranges[0]) + &quot; | r in &quot; + nameOf(obj.uri) + &quot;}&quot; + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#10;&#10;&#10;&#9;with open(fileName, &quot;w+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(AlloyModel)&#10;&#10;&#9;&#9;Alloy.write(AlloySignatures)&#10;&#10;&#9;&#9;Alloy.write(AlloyAxioms)&#10;&#10;&#9;&#9;Alloy.write(AlloyPredicates)&#10;&#10;&#10;&#9;AlloyUtils = &quot;&quot;&#10;&#9;AlloyUtilsFile = &quot;%{AlloyUtilsFile}&quot;&#10;&#9;with open(AlloyUtilsFile, &quot;r&quot;) as AlloyUtilsFileRead:&#10;&#9;&#9;AlloyUtils = AlloyUtilsFileRead.read()&#10;&#10;&#9;with open(fileName, &quot;a+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(&quot;\n&quot;)&#10;&#9;&#9;Alloy.write(AlloyUtils)&#10;&#10;&#9;#print(AlloyModel)"/>
        <parameter key="use_default_python" value="false"/>
        <parameter key="package_manager" value="specific python binaries"/>
        <parameter key="python_binary" value="/usr/bin/python2"/>
      </operator>
      <connect from_op="Read Excel" from_port="output" to_op="OWL+DL-&gt;Alloy" to_port="input 1"/>
      <portSpacing port="source_input 1" spacing="0"/>
      <portSpacing port="sink_result 1" spacing="0"/>
      <description align="center" color="yellow" colored="false" height="188" resized="true" width="543" x="857" y="486">Generate the Alloy Model as from:&lt;br&gt;https://pdfs.semanticscholar.org/e3b6/f7d0530892d00e785cb983b6a9b32c385e78.pdf</description>
      <description align="center" color="yellow" colored="false" height="103" resized="true" width="231" x="745" y="130">Requirements:&lt;br&gt;&lt;br&gt;ontospy:&lt;br/&gt;pip install ontospy</description>
      <description align="center" color="yellow" colored="false" height="177" resized="true" width="790" x="853" y="692">Create the Alloy Model as from:&lt;br&gt;https://www.researchgate.net/publication/220535396_Reasoning_support_for_Semantic_Web_ontology_family_languages_using_Alloy</description>
      <description align="center" color="blue" colored="true" height="475" resized="true" width="505" x="229" y="316">Set the macros used by the scripts:&lt;br&gt;- inputFile: RDF/OWL/N3/TTL file of the schema to convert&lt;br&gt;- outputDirectory: Directory where to store the results&lt;br/&gt;- AlloyDefinitions: .als file with Base OWL/RDFS Definitions used by AlloyCreator</description>
      <description align="center" color="yellow" colored="false" height="209" resized="true" width="424" x="851" y="257">Create the Alloy Model using:&lt;br/&gt;- DL Axioms from OWL2DL Legacy RapidMiner Process&lt;br&gt;- AlloyGenerator approach</description>
    </process>
  </operator>
</process>
