<?xml version="1.0" encoding="UTF-8"?><process version="9.6.000">
  <context>
    <input/>
    <output/>
    <macros/>
  </context>
  <operator activated="true" class="process" compatibility="9.4.000" expanded="true" name="Process">
    <parameter key="logverbosity" value="init"/>
    <parameter key="logfile" value="/Users/mattiafumagalli/Desktop/prova.log"/>
    <parameter key="resultfile" value="/Users/mattiafumagalli/prova.res"/>
    <parameter key="random_seed" value="2001"/>
    <parameter key="send_mail" value="never"/>
    <parameter key="notification_email" value=""/>
    <parameter key="process_duration_for_mail" value="30"/>
    <parameter key="encoding" value="UTF-8"/>
    <process expanded="true">
      <operator activated="true" class="set_macros" compatibility="9.6.000" expanded="true" height="68" name="Set Macros" width="90" x="514" y="340">
        <list key="macros">
          <parameter key="inputFile" value="/home/marco/Desktop/Alloy/InputCheck/yes.owl"/>
          <parameter key="outputDirectory" value="/home/marco/Desktop/Alloy/InputCheck/results/"/>
          <parameter key="AlloyUtilsFile" value="/home/marco/Desktop/Alloy/AlloyUtils.als"/>
        </list>
      </operator>
      <operator activated="true" class="ontology:load_axioms" compatibility="5.1.000" expanded="true" height="68" name="Load OWL Axioms" width="90" x="313" y="646">
        <parameter key="data_source" value="%{inputFile}"/>
        <parameter key="renderer_method" value="DLSyntax"/>
        <parameter key="only_logical_axioms" value="false"/>
        <parameter key="keep_TBox_axioms" value="true"/>
        <parameter key="keep_RBox_axioms" value="true"/>
        <parameter key="keep_ABox_axioms" value="true"/>
      </operator>
      <operator activated="true" class="ontology:filter_axioms" compatibility="5.1.000" expanded="true" height="82" name="Filter OWL Axioms" width="90" x="447" y="646">
        <parameter key="match_expression" value="..*"/>
        <parameter key="invert_condition" value="false"/>
      </operator>
      <operator activated="true" class="ontology:axioms_to_data" compatibility="5.1.000" expanded="true" height="68" name="Axioms to Data" width="90" x="581" y="646">
        <parameter key="axiom_attribute" value="DLAxioms"/>
        <parameter key="renderer_method" value="DLSyntax"/>
      </operator>
      <operator activated="true" class="python_scripting:execute_python" compatibility="9.2.000" expanded="true" height="103" name="OWL+DL-&gt;Alloy" width="90" x="782" y="595">
        <parameter key="script" value="#!/usr/bin/env python&#10;# -*- coding: utf-8 -*-&#10;&#10;&#10;# Based on:&#10;# https://www.researchgate.net/publication/272763162_A_Non-Standard_Approach_for_the_OWL_Ontologies_Checking_and_Reasoning&#10;# https://www.researchgate.net/publication/252772655_Model_Generation_in_Description_Logics_What_Can_We_Learn_From_Software_Engineering&#10;&#10;import os&#10;import pandas as pd&#10;import ontospy&#10;import re&#10;from rdflib import RDF, RDFS, OWL &#10;&#10;&#10;def nameOf(text):&#10;    return (str(text).split(&quot;/&quot;))[-1].split(&quot;#&quot;)[-1]&#10;&#10;&#10;def domains(property_):&#10;    property_domains = &quot;&quot;&#10;    if(property_.domains):&#10;        for domain_ in property_.domains:&#10;            property_domains = property_domains + str(domain_.uri) + &quot; &quot;&#10;    return property_domains.split()&#10;&#10;&#10;def ranges(property_):&#10;    property_ranges = &quot;&quot;&#10;    if(property_.ranges):&#10;        for range_ in property_.ranges:&#10;            property_ranges = property_ranges + str(range_.uri) + &quot; &quot;&#10;    return property_ranges.split()&#10;&#10;&#10;&#10;def brackets(complete):&#10;&#9;#print(complete)&#10;&#9;tmp = filter(None, complete.split(&quot;(&quot;) ) &#10;&#9;bracketed = &quot;&quot;&#10;&#9;c = 0 # Count level of opened brackets&#10;&#9;for t in tmp: # Iterate over the string to build the original one&#10;&#9;&#9;if(c):&#10;&#9;&#9;&#9;bracketed = bracketed + &quot; ( &quot;&#10;&#9;&#9;c = c + 1&#10;&#9;&#9;for i in t: # Iterate over every element to identify closed brackets&#10;&#9;&#9;&#9;if i == ')': # If a bracket is closed then update the opened brackets counter&#10;&#9;&#9;&#9;&#9;c = c - 1 &#10;&#9;&#9;&#9;&#9;if c &lt; 1: # If all the brackets has been closed then return the result&#10;&#9;&#9;&#9;&#9;&#9;return bracketed&#10;&#9;&#9;&#9;bracketed = bracketed + i&#10;&#10;&#9;while c &gt; 1: # If there are less closed brackets add the remaining ones&#10;&#9;&#9;bracketed = bracketed + &quot; ) &quot;&#10;&#9;&#9;c = c - 1 &#10;&#9;return bracketed # Return correctly formatted bracketed result&#10;&#10;# Return next expression inside brackets if the first string open a bracket&#10;def nextBrackets(next, complete):&#10;&#9;if(&quot;(&quot; in next): &#10;&#9;&#9;return brackets(&quot; &quot;.join(complete))&#10;&#9;else:&#10;&#9;&#9;return brackets(next)&#10;&#10;&#10;#[TODO] Check how to comment redundant Axiom (how to detect and comment) &#10;&#10;def DLAxiomtoAlloy(axiom, level):&#10;&#10;&#9;#print(axiom)&#10;&#9;&quot;&quot;&quot;&#10;&#9;if(len(axiom.split(&quot; &quot;)) == 1):&#10;&#9;&#9;print(axiom)&#10;&#9;&quot;&quot;&quot;&#10;&#9;# TBOX&#10;&#9;if(&quot;≡&quot; in axiom and level == 0):&#10;&#9;&#9;tmp = axiom.split(&quot;≡&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return  &quot;fact { &quot; + DLAxiomtoAlloy( tmp[0] , level + 1) + &quot; = &quot; + DLAxiomtoAlloy( tmp[1] , level + 1) + &quot; }&quot;&#10;&#10;&#9;elif(&quot;⊑&quot; in axiom and level == 0):&#10;&#9;&#9;tmp = axiom.split(&quot;⊑&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy( tmp[0] , level + 1) + &quot; in  ( &quot; + DLAxiomtoAlloy( tmp[1] , level + 1) + &quot; )  }&quot;&#10;&#9;&#10;&#9;if(&quot;=&quot; in axiom and level == 0):&#10;&#9;&#9;tmp = axiom.split(&quot;=&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy( tmp[0] , level + 1) + &quot; = &quot; + DLAxiomtoAlloy( tmp[1] , level + 1) + &quot; }&quot;&#10;&#10;&#9;# (ALC) concept&#10;&#9;elif(&quot;⊔&quot; in axiom):&#10;&#9;&#9;tmps = axiom.split(&quot;⊔&quot;)&#10;&#10;&#9;&#9;#print(tmps)&#10;&#10;&#9;&#9;final = &quot;  &quot;&#10;&#10;&#9;&#9;for tmp in tmps:&#10;&#9;&#9;&#9;final = final + DLAxiomtoAlloy(tmp , level + 1) + &quot; + &quot;&#10;&#10;&#9;&#9;final = final[0:-2]&#10;&#10;&#9;&#9;return final&#10;&#10;&#9;elif(&quot;⊓&quot; in axiom):&#10;&#9;&#9;tmps = axiom.split(&quot;⊓&quot;)&#10;&#10;&#9;&#9;#print(tmps)&#10;&#10;&#9;&#9;final = &quot;  &quot;&#10;&#10;&#9;&#9;for tmp in tmps:&#10;&#9;&#9;&#9;final = final + DLAxiomtoAlloy(tmp , level + 1) + &quot; &amp; &quot;&#10;&#10;&#9;&#9;final = final[0:-2]&#10;&#10;&#9;&#9;return final&#10;&#10;&#9;elif(&quot;∀&quot; in axiom):&#10;&#9;&#9;tmp = axiom.replace('∀', '').split(&quot;.&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#9;&#9;&#10;&#9;&#9;return &quot; ( univ - ( &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot;.( univ - &quot; + DLAxiomtoAlloy(nextBrackets(&quot;.&quot;.join(tmp[1:]).split()[0], &quot;.&quot;.join(tmp[1:]).split()) , level + 1) + &quot; ) ) ) &quot;&#10;&#9;&#9;&#10;&#9;elif(&quot;∃&quot; in axiom):&#10;&#9;&#9;tmp = axiom.replace('∃', '')&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return DLAxiomtoAlloy(tmp , level + 1)&#10;&#9;&#9;&#10;&#9;elif(&quot;¬&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;¬&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return  &quot;( univ - &quot; + DLAxiomtoAlloy(nextBrackets(tmp[1].split()[0], tmp[1].split()) , level + 1) + &quot; ) &quot;&#10;&#9;&#9;&#10;&#9;elif(&quot;⁻&quot; in axiom):&#10;&#9;&#9;&#10;&#9;&#9;#print(axiom)&#10;&#10;&#9;&#9;for tmp in axiom.split():&#10;&#9;&#9;&#9;if(&quot;⁻&quot; in tmp):&#10;&#10;&#9;&#9;&#9;&#9;return &quot;( ~ &quot; + DLAxiomtoAlloy(tmp.replace(&quot;⁻&quot;, &quot;&quot;) , level + 1) + &quot; ) &quot;&#10;&#10;&#9;# (SHIQ) concept&#10;&#10;&#9;elif(&quot;≤&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;≤&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;tmp = tmp[1]&#10;&#10;&#9;&#9;n = re.findall('\d+',  tmp)[0]&#10;&#10;&#9;&#9;tmp = tmp.replace(str(n),&quot;&quot;)&#10;&#9;&#9;&#10;&#9;&#9;if(&quot;.&quot; in tmp):&#10;&#9;&#9;&#9;tmp = tmp.split(&quot;.&quot;)&#10;&#10;&#9;&#9;&#9;#print(n)&#10;&#9;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp[0].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; :&gt; &quot; + DLAxiomtoAlloy(tmp[1].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) &lt;= &quot; + n + &quot;}&quot; &#10;&#9;&#9;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) &lt;= &quot; + n + &quot;}&quot; &#10;&#10;&#9;elif(&quot;≥&quot; in axiom):&#10;&#9;&#9;tmp = axiom.split(&quot;≥&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;tmp = tmp[1]&#10;&#10;&#9;&#9;n = re.findall('\d+',  tmp)[0]&#10;&#10;&#9;&#9;tmp = tmp.replace(str(n),&quot;&quot;)&#10;&#9;&#9;&#10;&#9;&#9;if(&quot;.&quot; in tmp):&#10;&#9;&#9;&#9;tmp = tmp.split(&quot;.&quot;)&#10;&#10;&#9;&#9;&#9;#print(n)&#10;&#9;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp[0].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; :&gt; &quot; + DLAxiomtoAlloy(tmp[1].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) &gt;= &quot; + n + &quot;}&quot; &#10;&#9;&#9;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) &gt;= &quot; + n + &quot;}&quot; &#10;&#10;&#9;elif(&quot;=&quot; in axiom and level &gt; 0):&#10;&#9;&#9;tmp = axiom.split(&quot;=&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;tmp = tmp[1]&#10;&#10;&#9;&#9;n = re.findall('\d+',  tmp)[0]&#10;&#10;&#9;&#9;tmp = tmp.replace(str(n),&quot;&quot;)&#10;&#9;&#9;&#10;&#9;&#9;if(&quot;.&quot; in tmp):&#10;&#9;&#9;&#9;tmp = tmp.split(&quot;.&quot;)&#10;&#10;&#9;&#9;&#9;#print(n)&#10;&#9;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp[0].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; :&gt; &quot; + DLAxiomtoAlloy(tmp[1].replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) = &quot; + n + &quot;}&quot; &#10;&#9;&#9;&#10;&#9;&#9;else:&#10;&#9;&#9;&#9;return &quot;{ a : univ | #( a.( &quot; + DLAxiomtoAlloy(tmp.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;) , level + 1) + &quot; ) ) = &quot; + n + &quot;}&quot; &#10;&#9;&#10;&#9;elif(&quot;INV.&quot; in axiom):&#10;&#9;&#9;tmp = axiom.replace(&quot;INV.&quot;, &quot;~&quot;)&#10;&#10;&#9;&#9;#print(tmp)&#10;&#10;&#9;&#9;return DLAxiomtoAlloy(tmp , level + 1)&#10;&#10;&#10;&#9;elif(&quot;(&quot; in axiom and &quot;)&quot; in axiom and level == 0):&#10;&#9;&#9;tmp = axiom.split(&quot;(&quot;)&#10;&#9;&#9;C = tmp[0].split()[-1]&#10;&#9;&#9;tmp = tmp[1].split(&quot;)&quot;)[0]&#10;&#9;&#9;tmp = tmp.split(&quot;,&quot;)&#10;&#10;&#9;&#9;if(len(tmp)==1):&#10;&#9;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot; in &quot; + C + &quot; }&quot;&#10;&#9;&#9;elif(len(tmp)==2):&#10;&#9;&#9;&#9;return &quot;fact { &quot; + DLAxiomtoAlloy(tmp[0] , level + 1) + &quot; -&gt; &quot; + DLAxiomtoAlloy(tmp[1] , level + 1) + &quot; in &quot; + C + &quot; }&quot;&#10;&#9;&#9;&#10;&#9;&#9;return axiom&#10;&#10;&#10;&#9;return axiom.replace(&quot;(&quot;,&quot;&quot;).replace(&quot;)&quot;,&quot;&quot;)&#10;&#10;&#10;def rm_main(dataDL):&#10;&#10;&#9;# Create the directory in which store the new vocabulary&#10;&#9;outputDirectory = &quot;%{outputDirectory}&quot;&#10;&#9;if not os.path.isdir(outputDirectory):&#10;&#9;&#9;os.makedirs(outputDirectory)&#10;&#10;&#9;# Define Ontology Analyser&#9;&#10;&#9;o = ontospy.Ontospy()&#10;&#9;# Load Ontology&#10;&#9;inputFile = &quot;%{inputFile}&quot; #, people.owl, Animal.owl, schema_2020-03-10.n3&#10;&#9;o.load_rdf(inputFile)&#10;&#9;o.build_all()&#10;     &#10;&#9;moduleName = ((str(inputFile).split(&quot;/&quot;)[-1]).split(&quot;.&quot;))[-2] + &quot;DL&quot;&#10;&#9;fileName = outputDirectory + moduleName + &quot;.als&quot;&#10;&#9;&#10;&#9;AlloyModel = &quot;module &quot; + moduleName + &quot;\n\n&quot;&#10;&#10;&#9;usedProperties = set()&#10;&#9;usedDataTypes = set()&#10;&#10;&#9;AlloySignatures = &quot;// Specific Signatures\n&quot;&#10;&#10;&#9;# Add Classes &amp; Properties to Alloy&#10;&#9;for class_ in o.all_classes:&#10;&#9;&#9;#print(&quot;Class: &quot; + str(class_.uri))&#10;&#9;&#9;className = nameOf(class_.uri)&#10;&#10;&#9;&#9;AlloyClass = &quot;sig &quot; + className + &quot; in TOP &quot;&#10;&#10;&#9;&#9;AlloyClass = AlloyClass + &quot; { \n\t&quot;&#10;&#10;&#9;&#9;for property_ in o.all_properties:&#10;&#9;&#9;&#9;#print(&quot;Property: &quot; + str(property_.uri))&#10;&#9;&#9;&#9;domains_ = domains(property_)&#10;&#9;&#9;&#9;if(len(domains_) == 1):&#10;&#9;&#9;&#9;&#9;property_Name = nameOf(property_.uri)&#10;&#9;&#9;&#9;&#9;for domain_ in domains_:&#10;&#9;&#9;&#9;&#9;&#9;if(domain_ == str(class_.uri)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;#print(&quot;Domain: &quot; + str(domain_))&#10;&#9;&#9;&#9;&#9;&#9;&#9;ranges_ = ranges(property_)&#10;&#9;&#9;&#9;&#9;&#9;&#9;if(len(ranges_) == 1):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;#print(&quot;Range: &quot; + str(range_))&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rangeName = nameOf(ranges_[0])&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AlloyClass = AlloyClass + property_Name + &quot;: set &quot; + rangeName + &quot;,\n\t&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;usedProperties.add(property_)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;usedDataTypes.add(rangeName)&#10;&#9;&#9;&#9;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AlloyClass = AlloyClass + property_Name + &quot;: set TOP,\n\t&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;usedProperties.add(property_)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;&#9;#print()&#10;&#9;&#9;&#9;#print()&#10;&#9;&#9;AlloyClass = AlloyClass[0:-3] + &quot;} \n&quot;&#10;&#9;&#9;&#10;&#9;&#9;AlloySignatures = AlloySignatures + AlloyClass&#10;&#9;&#9;#print()&#10;&#10;&#10; &#9;# Define TOP with remaining properties&#10;&#9;AlloyModel = AlloyModel + &quot;// General Signatures\n&quot;&#10;&#9;AlloyModel = AlloyModel + &quot;abstract sig TOP { \n&quot;&#10;&#10;&#9;for property_ in o.all_properties:&#10;&#9;&#9;property_Name = nameOf(property_.uri)&#10;&#9;&#9;if(property_ not in usedProperties):&#10;&#9;&#9;&#9;# Don't take into account AnnotationProperties of OWL&#10;&#9;&#9;&#9;if (property_.uri, RDF.type, OWL.AnnotationProperty) not in o.rdflib_graph:&#10;&#10;&#9;&#9;&#9;&#9;ranges_ = ranges(property_)&#10;&#9;&#9;&#9;&#9;if(len(ranges_) == 1):&#10;&#9;&#9;&#9;&#9;&#9;rangeName = nameOf(ranges_[0])&#10;&#9;&#9;&#9;&#9;&#9;if(rangeName == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;rangeName = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;\t&quot; + property_Name + &quot;: set &quot; + rangeName + &quot;,\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;usedDataTypes.add(rangeName)&#10;&#9;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;&#9;AlloyModel = AlloyModel + &quot;\t&quot; + property_Name + &quot;: set TOP,\n&quot;&#10;&#10;&#9;AlloyModel = AlloyModel[0:-2] + &quot;}\n&quot;&#10;&#10;&#9;AlloyModel = AlloyModel + &quot;sig BOTTOM in TOP {} fact { #BOTTOM = 0 } \n\n&quot;&#10;&#10;&#9;unUsedProperties = set(o.all_properties) - usedProperties&#10;&#9;unUsedPropertiesLabels = set()&#10;&#9;for uUP in unUsedProperties:&#10;&#9;&#9;unUsedPropertiesLabels.add(nameOf(uUP.uri))&#10;&#10;&#9;&quot;&quot;&quot;&#10;&#9;# To add if we want to keep also class relations&#10;&#9;validLabels = unUsedPropertiesLabels&#10;&#9;for validClass in o.all_classes:&#10;&#9;&#9;validLabels.add(nameOf(validClass.uri))&#10;&#9;&quot;&quot;&quot;&#10;&#10;&#9;AlloyAxioms = &quot;\n// Axioms\n&quot;&#10;&#9;AlloyAxiomsComment = &quot;\n// Non Relevant Axioms\n&quot;&#10;&#10;&#9;# Iterate for every DL Axioms&#10;&#9;for index, row in dataDL.iterrows():&#10;&#10;&#9;&#9;if (row[&quot;DLAxioms&quot;]):&#10;&#10;&#9;&#9;&#9;axioms = row[&quot;DLAxioms&quot;].encode('utf-8').strip()&#10;&#10;&#9;&#9;&#9;# Split across multiple axioms on same row&#10;&#9;&#9;&#9;for axiom in axioms.split(&quot;,&quot;):&#10;&#9;&#9;&#9;&#9;AlloyAxiom = axiom&#10;&#9;&#9;&#9;&#9;if(&quot;⊤&quot; in axiom):&#10;&#9;&#9;&#9;&#9;&#9;checkAxiomRange = axiom.split(&quot;.⊤&quot;)[0].split(&quot; &quot;)[-1]&#10;&#9;&#9;&#9;&#9;&#9;rangeReplacement = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;for property_ in o.all_properties:&#10;&#9;&#9;&#9;&#9;&#9;&#9;property_Name = nameOf(property_.uri)&#10;&#9;&#9;&#9;&#9;&#9;&#9;if(property_Name == checkAxiomRange):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ranges_ = ranges(property_)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if(len(ranges_) == 1):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rangeReplacement = nameOf(ranges_[0])&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if(rangeReplacement == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;rangeReplacement = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyAxiom = DLAxiomtoAlloy(axiom.replace(&quot;⊤&quot;, rangeReplacement).replace(&quot;,&quot;, &quot;&quot;), 0)&#10;&#10;&#9;&#9;&#9;&#9;if (AlloyAxiom[0] == &quot;{&quot;):&#10;&#9;&#9;&#9;&#9;&#9;print(AlloyAxiom)&#10;&#9;&#9;&#9;&#9;&#9;AlloyAxiom = &quot;fact &quot; + AlloyAxiom&#10;&#9;&#9;&#9;&#9;#print(AlloyAxiom)&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;if(&quot;fact {&quot; in AlloyAxiom[0:6]):&#10;&#9;&#9;&#9;&#9;&#9;comment = &quot;// &quot;&#10;&#9;&#9;&#9;&#9;&#9;for label in unUsedPropertiesLabels:&#10;&#9;&#9;&#9;&#9;&#9;&#9;if(label in AlloyAxiom):&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;comment = &quot;&quot;&#10;&#9;&#9;&#9;&#9;&#9;if(comment):&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyAxiomsComment = AlloyAxiomsComment + comment + AlloyAxiom + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;&#9;&#9;AlloyAxioms = AlloyAxioms + comment + AlloyAxiom + &quot;\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;#print(&quot;&quot;)&#10;&#10;&#9;AlloyProperties = &quot;\n// Properties\n&quot;&#10;&#10;&#9;for subject, predicate, object_ in o.rdflib_graph:&#10;&#9;&#9;#print(subject, predicate, object_)&#10;&#9;&#9;#print()&#10;&#9;&#9;&#10;&#9;&#9;predicateName = nameOf(predicate.encode('utf-8').strip())&#10;&#9;&#9;&#10;&#9;&#9;subj = o.get_any_entity(uri=subject.encode('utf-8').strip())&#10;&#9;&#9;pred = o.get_any_entity(uri=predicate.encode('utf-8').strip())&#10;&#9;&#9;obj = o.get_any_entity(uri=object_.encode('utf-8').strip())&#10;&#10;&#9;&#9;# PREDICATE MAPPING FROM OWL TO ALLOY&#10;&#9;&#9;if(subj and obj and predicateName != &quot;type&quot;):&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;if predicateName == &quot;subPropertyOf&quot;:       &#10;&#9;&#9;&#9;&#9;subj_range = &quot;&quot;&#10;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(subj)[1:9] and subj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(subj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;subj_range = subj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;elif(&quot;Class&quot; == str(subj)[1:6] and subj.range_of):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(subj.range_of))&#10;&#9;&#9;&#9;&#9;&#9;subj_range = subj.range_of[0].uri            &#10;&#10;&#9;&#9;&#9;&#9;if(nameOf(subj_range) and nameOf(subj.uri) and nameOf(obj.uri)):&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact {all a:&quot; + nameOf(subj_range) + &quot; | a.&quot; + nameOf(subj.uri) + &quot; in a.&quot; + nameOf(obj.uri) + &quot;} // subPropertyOf as Figure4\n&quot;&#10;&#10;&#9;&#9;&#9;&#9;obj_range = &quot;&quot;&#10;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(obj)[1:9] and obj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(obj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;obj_range = obj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;elif(&quot;Class&quot; == str(obj)[1:6] and obj.range_of):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(obj.range_of))&#10;&#9;&#9;&#9;&#9;&#9;obj_range = obj.range_of[0].uri&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;&#9;if(nameOf(subj_range) and nameOf(obj_range)):&#10;&#9;&#9;&#9;&#9;&#9;obj_range = nameOf(obj_range)&#10;&#9;&#9;&#9;&#9;&#9;if(obj_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;obj_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact {all r:&quot; + nameOf(subj_range) + &quot; | r in &quot; + obj_range + &quot;} // subPropertyOf as TABLE I\n&quot;&#10;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;elif predicateName == &quot;inverseOf&quot;:&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact {&quot; + nameOf(subj.uri) + &quot; = ~&quot; + nameOf(obj.uri) + &quot;} // inverseOf\n&quot;&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;disjointWith&quot;:&#10;&#9;&#9;&#9;&#9;if(subj.parents() and obj.parents() and subj.parents()[0] != obj.parents()[0]):&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { no c1:&quot; + nameOf(subj.uri) + &quot;, c2:&quot; + nameOf(obj.uri) + &quot;| c1 = c2} // disjointWith\n&quot;&#10;&#9;&#9;&#9;&#9;&#9;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;complementOf&quot;:&#10;&#9;&#9;&#9;&#9;C = &quot;{&quot;&#10;&#9;&#9;&#9;&#9;for class_ in o.all_classes:&#10;&#9;&#9;&#9;&#9;&#9;if(nameOf(obj.uri) != nameOf(class_.uri)):&#10;&#9;&#9;&#9;&#9;&#9;&#9;C = C + nameOf(class_.uri)&#10;&#9;&#9;&#9;&#9;C = C + &quot;}&quot;&#10;&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { &quot; + nameOf(subj.uri) + &quot; = &quot; + str(C) + &quot;} // complementOf\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;equivalentClass&quot;:&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { &quot; + nameOf(subj.uri) + &quot; = &quot; + nameOf(obj.uri) + &quot;} // equivalentClass\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;equivalentProperty&quot;:&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { &quot; + nameOf(subj.uri) + &quot; = &quot; + nameOf(obj.uri) + &quot;} // equivalentProperty\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;TransitiveProperty&quot;:&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { a,b,c ∈ &quot; + nameOf(subj.uri) + &quot; / a.(&quot; + nameOf(predicate) + &quot;) = b &amp;&amp; b.(&quot; + nameOf(predicate) + &quot;) = c ⇒ a.(&quot; + nameOf(predicate) + &quot;) = c } // TransitiveProperty\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;hasValue&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { #( &quot; + pred_range + &quot; ) = 1} // hasValue\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;cardinality&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { #( &quot; + pred_range + &quot; ) = &quot; + nameOf(obj.uri) + &quot;} // cardinality\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;maxCardinality&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { #( &quot; + pred_range + &quot; ) &lt;= &quot; + nameOf(obj.uri) + &quot;} // maxCardinality\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;minCardinality&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { #( &quot; + pred_range + &quot; ) &gt;= &quot; + nameOf(obj.uri) + &quot;} // minCardinality\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;SymmetricProperty&quot;:&#10;&#9;&#9;&#9;&#9;if(((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)) and ((&quot;Property&quot; == str(pred)[1:9] and pred.domains) or (&quot;Class&quot; == str(pred)[1:6] and pred.domain_of))):&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { a ∈ &quot; + pred.domains[0] + &quot; &amp;&amp;  b ∈ &quot; + pred.ranges[0] + &quot; / a.(&quot; + nameOf(predicate) + &quot;)  = b ⇒ b.(&quot; + nameOf(predicate) + &quot;) } // SymmetricProperty\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;FunctionalProperty&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { #(&quot; + pred_range + &quot;) = 1} //FunctionalProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;InverseFunctionalProperty&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.domains) or (&quot;Class&quot; == str(pred)[1:6] and pred.domain_of)):&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { #(&quot; + pred.domains[0] + &quot;) = 1} // InverseFunctionalProperty\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;allValuesFrom&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { &quot; + pred_range + &quot; in &quot; + nameOf(obj.uri) + &quot;} // allValuesFrom\n&quot;&#10;&#10;&#9;&#9;&#9;elif predicateName ==  &quot;someValuesFrom&quot;:&#10;&#9;&#9;&#9;&#9;if((&quot;Property&quot; == str(pred)[1:9] and pred.ranges) or (&quot;Class&quot; == str(pred)[1:6] and pred.range_of)):&#10;&#9;&#9;&#9;&#9;&#9;pred_range = nameOf(pred.ranges[0])&#10;&#9;&#9;&#9;&#9;&#9;if(pred_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;pred_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { some r: &quot; + pred_range + &quot; | r in &quot; + nameOf(obj.uri) + &quot;} // someValuesFrom\n&quot;&#10;&#10;&#9;&#9;# META-PROPERTY OF OWL TO ALLOY&#10;&#9;&#9;elif(predicateName == &quot;type&quot;):&#10;&#9;&#9;&#9;&#10;&#9;&#9;&#9;if(nameOf(object_) == &quot;FunctionalObjectProperty&quot;):&#10;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(subj)[1:9] and subj.ranges):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(subj.ranges))&#10;&#9;&#9;&#9;&#9;&#9;subj_range = subj.ranges[0].uri&#10;&#9;&#9;&#9;&#9;&#9;if(subj_range == &quot;Thing&quot;):&#10;&#9;&#9;&#9;&#9;&#9;&#9;subj_range = &quot;TOP&quot;&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { all c: &quot; + subj_range + &quot;| lone &quot; + nameOf(subject)+ &quot;.c } // FunctionalObjectProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif(nameOf(object_) == &quot;InverseFunctionalProperty&quot;):&#10;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(subj)[1:9] and subj.domains):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(subj.domains))&#10;&#9;&#9;&#9;&#9;&#9;subj_domain = subj.domains[0].uri&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { all c: &quot; + subj_domain + &quot;| lone c.&quot; + nameOf(subject)+ &quot; } // InverseFunctionalProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif(nameOf(object_) == &quot;TransitiveProperty&quot;):&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { &quot; + nameOf(subj.uri) + &quot;.&quot; + nameOf(subj.uri) + &quot; in &quot; + nameOf(subj.uri) + &quot; } // TransitiveProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif(nameOf(object_) == &quot;SymmetricProperty&quot;):&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact { ~&quot; + nameOf(subj.uri) + &quot; in &quot; + nameOf(subj.uri) + &quot; } // SymmetricProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif(nameOf(object_) == &quot;AsymmetricProperty&quot;):&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact {~&quot; + nameOf(subj.uri) + &quot;  &amp; &quot; + nameOf(subj.uri) + &quot; in iden} // AsymmetricProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif(nameOf(object_) == &quot;ReflexiveProperty&quot;):&#10;&#9;&#9;&#9;&#9;if(&quot;Property&quot; == str(subj)[1:9] and subj.domains):&#10;&#9;&#9;&#9;&#9;&#9;#print(len(subj.domains))&#10;&#9;&#9;&#9;&#9;&#9;subj_domain = subj.domains[0].uri&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact {&quot; + subj_domain + &quot;&lt;:iden in &quot; + nameOf(subj.uri) + &quot;} // ReflexiveProperty \n&quot;&#10;&#10;&#9;&#9;&#9;elif(nameOf(object_) == &quot;IrreflexiveProperty&quot;):&#10;&#9;&#9;&#9;&#9;AlloyProperties = AlloyProperties + &quot;fact {no iden &amp; &quot; + nameOf(subj.uri) + &quot;} // IrreflexiveProperty \n&quot;&#10;&#10;&#10;&#9;with open(fileName, &quot;w+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(AlloyModel)&#10;&#10;&#9;&#9;Alloy.write(AlloySignatures)&#10;&#10;&#9;&#9;Alloy.write(AlloyProperties)&#10;&#10;&#9;&#9;Alloy.write(AlloyAxioms)&#10;&#10;&#9;&#9;Alloy.write(AlloyAxiomsComment)&#10;&#10;&#10;&#9;# Comment unUsed DataTypes&#10;&#9;AlloyUtils = &quot;&quot;&#10;&#9;AlloyUtilsFile = &quot;%{AlloyUtilsFile}&quot;&#10;&#9;with open(AlloyUtilsFile, &quot;r&quot;) as AlloyUtilsFileRead:&#10;&#9;&#9;if(&quot;TOP&quot; in usedDataTypes):&#10;&#9;&#9;&#9;usedDataTypes.remove(&quot;TOP&quot;)&#10;&#9;&#9;for line in AlloyUtilsFileRead.readlines():&#10;&#9;&#9;&#9;if(len(line) &gt; 1 and line[0:2] != &quot;//&quot;):&#10;&#9;&#9;&#9;&#9;comment = &quot;// &quot;&#10;&#9;&#9;&#9;&#9;for datatype in usedDataTypes:&#10;&#9;&#9;&#9;&#9;&#9;if(datatype in line):&#10;&#9;&#9;&#9;&#9;&#9;&#9;comment = &quot;&quot;&#10;&#9;&#9;&#9;&#9;AlloyUtils = AlloyUtils + comment + line.strip() + &quot;\n&quot;&#10;&#9;&#9;&#9;else:&#10;&#9;&#9;&#9;&#9;AlloyUtils = AlloyUtils + line.strip() + &quot;\n&quot;&#10;&#10;&#9;with open(fileName, &quot;a+&quot;) as Alloy:&#10;&#9;&#9;Alloy.write(&quot;\n&quot;)&#10;&#9;&#9;Alloy.write(AlloyUtils)&#10;&#10;&#9;#print(AlloyModel)"/>
        <parameter key="use_default_python" value="false"/>
        <parameter key="package_manager" value="specific python binaries"/>
        <parameter key="python_binary" value="/usr/bin/python2"/>
      </operator>
      <connect from_op="Load OWL Axioms" from_port="output" to_op="Filter OWL Axioms" to_port="axioms"/>
      <connect from_op="Filter OWL Axioms" from_port="axioms" to_op="Axioms to Data" to_port="axioms"/>
      <connect from_op="Axioms to Data" from_port="example set" to_op="OWL+DL-&gt;Alloy" to_port="input 1"/>
      <portSpacing port="source_input 1" spacing="0"/>
      <portSpacing port="sink_result 1" spacing="0"/>
      <description align="center" color="yellow" colored="false" height="160" resized="true" width="358" x="385" y="33">RapidMiner Extensions requirements:&lt;br&gt;rmx_ontology = 5.1&lt;br&gt;rmx_text = 9.3&lt;br/&gt;&lt;br&gt;Python Library:&lt;br&gt;ontospy:&lt;br&gt;pip install ontospy</description>
      <description align="center" color="blue" colored="true" height="284" resized="true" width="507" x="289" y="230">Set the macros used by the scripts:&lt;br&gt;- inputFile: RDF/OWL/N3/TTL file of the schema to convert&lt;br&gt;- outputDirectory: Directory where to store the results&lt;br&gt;- AlloyUtilsFile: .als file with Base OWL/RDFS Definitions</description>
      <description align="center" color="yellow" colored="false" height="292" resized="true" width="704" x="240" y="529">Create the Alloy Model using:&lt;br&gt;- DL Axioms from OWL&lt;br&gt;- AlloyGenerator approach</description>
    </process>
  </operator>
</process>
